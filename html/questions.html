<!DOCTYPE html>
<html>
    <head>
        <link rel="icon" href="../favicon.png" />
        <link rel="stylesheet" href="../styles/global.css">
        <title>ciabatta</title>
    </head>

    <body>
        <div class="back-home">
            <a href="../index.html">←0. back home</a>
        </div>
        
        <div class="hero" style="margin-top: 19.5em;">
            <h1 class="hero-title">this is </h1>
            <h1 class="hero-title" style="color: #b2dd6b;">ciabatta.</h1>
            <p>ciabatta is a place for practice questions :)</p>
        </div>

        <div class="topic">
            <h2 class="topic-title">easy</h2>
            <p class="text">
                <a href="https://leetcode.com/problems/valid-palindrome/" target="blank">valid palindrome↗︎</a>: 
                given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. <br> 
            </p>
            <button class="collapsible">my solution ▾</button>
            <div class="content">
                <p>i solved this using the two pointer approach. 
                <br>time complexity: O(<i>n</i>) because we only need to traverse the string once; will access <i>n</i> elements. <br>space complexity: O(1) because we only require the two pointers.</p>
                <p class="code" style="background-color: #ecfad8;">
                    def isPalindrome(self, str): <br>
                    &emsp;str = str.lower() <br>
                    &emsp;l = len(str) <br>
                    &emsp;p1 = 0 <br>
                    &emsp;p2 = l - 1 <br>
                    &emsp;while p1 < p2: <br>
                    &emsp; &emsp;if str[p1].isalnum() == False: <br>
                    &emsp; &emsp; &emsp;p1+=1 <br><br>
                    &emsp; &emsp;elif str[p2].isalnum() == False: <br>
                    &emsp; &emsp; &emsp;p2-=1<br><br>
                    &emsp; &emsp;elif str[p1] == str[p2]: <br>
                    &emsp; &emsp; &emsp;p1+=1<br>
                    &emsp; &emsp; &emsp;p2-=1<br><br>
                    &emsp; &emsp;else:<br>
                    &emsp;&emsp; &emsp;return False<br><br>
                    &emsp;return True<br>
                </p>
            </div>
        </div>
        

        <div class="topic">
            <h2 class="topic-title">medium</h2>
            <p class="text">
                <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="blank">find first and last position↗︎</a>: 
                given an array of sorted integers, find the starting and ending position of a given target value in O(<i>log n</i>) time. <br> 
            </p>
            <button class="collapsible">my solution ▾</button>
            <div class="content">
                <p>i solved this using binary search: basically, we search for the first and last occurrences of the target value. this is done by modifying the traditional binary search, as shown below.
                <br>on a side note: "array of sorted integers" should indicate that binary search may be an option. 
                <br>time complexity: O(<i>log n</i>), the search interval is being divided in half at every iteration. <br>space complexity: O(1) because we only need to store a constant amount of values.</p>
                <p class="code" style="background-color: #ecfad8;">
                    def searchRange(self, nums, target): <br>
                    &emsp;start = end = -1 <br>
                    &emsp;left = 0 <br>
                    &emsp;right = len(nums) - 1 <br><br>
                    &emsp;#find first occurrence <br>
                    &emsp;while left <= right: <br>
                    &emsp; &emsp;mid = (left + right) / 2 <br>
                    &emsp; &emsp;if nums[mid] == target: <br>
                    &emsp; &emsp; &emsp;start = mid <br>
                    &emsp; &emsp; &emsp;right = mid - 1<br>
                    &emsp; &emsp;elif nums[mid] < target: <br>
                    &emsp; &emsp; &emsp;left = mid + 1<br>
                    &emsp; &emsp;elif nums[mid] > target: <br>
                    &emsp; &emsp; &emsp;right = mid - 1<br><br>
                    &emsp;#find last occurrence <br>
                    &emsp;left = 0 <br>
                    &emsp;right = len(nums) - 1 <br><br>
                    &emsp;while left <= right: <br>
                    &emsp; &emsp;mid = (left + right) / 2 <br>
                    &emsp; &emsp;if nums[mid] == target: <br>
                    &emsp; &emsp; &emsp;end = mid <br>
                    &emsp; &emsp; &emsp;left = mid + 1<br>
                    &emsp; &emsp;elif nums[mid] < target: <br>
                    &emsp; &emsp; &emsp;left = mid + 1<br>
                    &emsp; &emsp;elif nums[mid] > target: <br>
                    &emsp; &emsp; &emsp;right = mid - 1<br><br>
                    &emsp;return [start, end]<br>
                </p>
            </div>

            <p class="text">
                <a href="https://leetcode.com/problems/sort-colors/" target="blank">sort colors↗︎</a>: 
                given an array with colors (0, 1, 2), sort them in-place so that the same colors are adjacent to each other. <br> 
            </p>
            <button class="collapsible">my solution ▾</button>
            <div class="content">
                <p>there are many ways to solve this problem, but i decided to make two passes: first, count the number of 0's, 1's, and 2's; 
                    second, overwrite the given array with the proper values in the proper place.
                <br>other methods that i can think of include: two pointers, and merge/quick sort. 
                <br>time complexity: two passes => <i>2n</i>, O(<i>n</i>) <br>space complexity: O(1) because we only need to store a constant amount of values.</p>
                <p class="code" style="background-color: #ecfad8;">
                    def sortColors(self, nums): <br>
                    &emsp;red = white = blue = 0 <br>
                    &emsp;for x in range(len(nums)): <br>
                    &emsp;&emsp;if nums[x] == 0 <br>
                    &emsp;&emsp;&emsp;red+=1 <br>
                    &emsp;&emsp;if nums[x] == 1 <br>
                    &emsp;&emsp;&emsp;white+=1 <br>
                    &emsp;&emsp;if nums[x] == 2 <br>
                    &emsp;&emsp;&emsp;blue+=1 <br><br>
                    &emsp;&emsp;for x in range(red):<br>
                    &emsp;&emsp;&emsp;nums[x] = 0 <br>
                    &emsp;&emsp;for x in range(red, red + white):<br>
                    &emsp;&emsp;&emsp;nums[x] = 1 <br>
                    &emsp;&emsp;for x in range(red + white, len(nums)):<br>
                    &emsp;&emsp;&emsp;nums[x] = 2 <br><br>
                    &emsp;return nums<br>
                </p>
            </div>
        </div>

        <div class="topic">
            <h2 class="topic-title">hard</h2>
            <p>this is hard content</p>
        </div>

        <div class="nav">
            <a href="misc.html" style="float: left;">←5. multigrain</a>
        </div>

        <script>
            var coll = document.getElementsByClassName("collapsible");
            var i;
            
            for (i = 0; i < coll.length; i++) {
              coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight){
                  content.style.maxHeight = null;
                } else {
                  content.style.maxHeight = content.scrollHeight + "px";
                } 
              });
            }
        </script>
    </body>
</html>